/*
 *  This file is part of "TweetyProject", a collection of Java libraries for
 *  logical aspects of artificial intelligence and knowledge representation.
 *
 *  TweetyProject is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 *  Copyright 2018 The TweetyProject Team <http://tweetyproject.org/contact/>
 */
package org.tweetyproject.arg.dung.principles;

import org.junit.jupiter.params.shadow.com.univocity.parsers.csv.CsvWriter;
import org.tweetyproject.arg.dung.reasoner.AbstractExtensionReasoner;
import org.tweetyproject.arg.dung.semantics.Extension;
import org.tweetyproject.arg.dung.syntax.DungTheory;
import org.tweetyproject.arg.dung.util.DungTheoryGenerator;
import org.tweetyproject.commons.postulates.PostulateEvaluatable;
import org.tweetyproject.commons.postulates.PostulateEvaluationReport;
import org.tweetyproject.commons.postulates.PostulateEvaluator;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;

/**
 * Evaluates a DungTheory wrt. a series
 * of princples .
 * 
 * @author Carola Bauer
 *
 */
public class ExtensionbasedPrincipleEvaluator extends PostulateEvaluator {



	/**
	 * Creates a new evaluator for the given evaluatable and
	 * belief base generator.
	 * @param iterator some belief set iterator
	 * @param ev some evaluatable
	 * @param principles a set of principles
	 */
	public ExtensionbasedPrincipleEvaluator(DungTheoryGenerator iterator, AbstractExtensionReasoner ev, Collection<Principle> principles) {
		super(iterator,ev, principles );

	}

	/**
	 * Creates a new evaluator for the given evaluatable and
	 * belief base generator.
	 * @param iterator DungTheoryGenerator belief set iterator
	 * @param ev AbstractExtensionReasoner evaluatable
	 */
	public ExtensionbasedPrincipleEvaluator(DungTheoryGenerator iterator, AbstractExtensionReasoner ev) {
		super(iterator, ev);
	}
	


	/**
	 * Evaluates all principles of this evaluator on the given 
	 * approach on <code>num</code> belief bases generated by
	 * the sampler of this evaluator.
	 * @param num the number of belief bases to be applied.
	 * @param stopWhenFailed if true the evaluation of one principle
	 * 	will be stopped once a violation has been encountered.
	 * @return a report on the evaluation
	 */
	public PostulateEvaluationReport evaluate(long num, boolean stopWhenFailed) {
		PostulateEvaluatable ev = this.getEv();
		PostulateEvaluationReport rep = new PostulateEvaluationReport(ev,this.getPostulates());
		Collection<Principle> failedPrinciples = new HashSet<>();
		Collection<Extension<DungTheory>> exts;
		DungTheory instance;
		for(int i = 0; i < num; i++) {
			instance = (DungTheory) this.getIterator().next();

			exts = ((AbstractExtensionReasoner) ev).getModels(instance);
			rep.addPercentage(Double.valueOf(exts.stream().findFirst().get().size())/Double.valueOf(instance.getNumberOfNodes()));
			for(var principle: (List<Principle>)this.getPostulates()) {
				System.out.println(principle);
				if(stopWhenFailed && failedPrinciples.contains(principle))
					continue;
				if(!principle.isApplicable(instance))
					rep.addNotApplicableInstance(principle, instance);
				else if(principle.isSatisfied(instance, exts, (AbstractExtensionReasoner) this.getEv()))
					rep.addPositiveInstance(principle, instance);
				else {
					rep.addNegativeInstance(principle, instance);
					failedPrinciples.add(principle);
					//System.out.println(instance+" "+principle.getName());
				}
			}

		}

		return rep;
	}



}
